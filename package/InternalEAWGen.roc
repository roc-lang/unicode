## The purpose of this file is to generate the InternalEAW.roc file.
##
## This file will read the test data from `data/EastAsianWidth-15.1.0.txt`
## parse it and then generate function to test the East Asian Width property of a code point.
app [main!] {
    pf: platform "../../basic-cli/platform/main.roc",
}

import pf.Stdout
import "data/EastAsianWidth-15.1.0.txt" as file : Str
import Helpers

EawRange : (Str, Str, Str)

main! = |_args| Stdout.line!(template)

template =
    """
    ## WARNING This file is automatically generated. Do not edit it manually. ##
    module [east_asian_width_property, east_asian_width]

    east_asian_width : U32 -> U32
    east_asian_width = |code_point|
        when east_asian_width_property(code_point) is
            F | W | A -> 2
            H | N | Na -> 1

    east_asian_width_property = |cp| ${tests_str}

    ${all_tests}
    """

# The ranges are specified as its starting point and an optional inclusive end point
# if it's length is greater than 1. The range is followed by the East_Asian_Width property
# separated by a semicolon.
# Examples:
# 0000..001F     ; N    # The property may be followed by comments
# 0020           ; Na
parse_line : Str -> Result EawRange _
parse_line = |line|
    list_to_parsing_state = |rest| { val: [], rest }

    start_hex_bytes =
        line
        |> Str.to_utf8
        |> list_to_parsing_state
        |> Helpers.take_hex_bytes

    end_hex_bytes =
        when start_hex_bytes.rest is
            ['.', '.', .. as rest] -> rest |> list_to_parsing_state |> Helpers.take_hex_bytes
            _ -> start_hex_bytes # This range has length 1. The start will be repeated as the end

    end_hex_bytes.rest
    |> List.split_first(';')
    |> Result.map_ok(|{ after }| after)
    |> Result.try(|commentd_eap| List.split_first(commentd_eap, '#'))
    |> Result.map_ok(|{ before }| before)
    |> Result.try(Str.from_utf8)
    |> Result.map_ok(Str.trim)
    |> Result.try(
        |eawp|
            start_hex_bytes.val
            |> Str.from_utf8
            |> Result.map_ok(|start| (eawp, "0x${start}")),
    )
    |> Result.try(
        |(eawp, start)|
            end_hex_bytes.val
            |> Str.from_utf8
            |> Result.map_ok(|end| (eawp, start, "0x${end}")),
    )

expect parse_line("0020           ; Na # Zs         SPACE") == Ok(("Na", "0x0020", "0x0020"))
expect parse_line("0025..0027     ; Na # Po     [3] PERCENT SIGN..APOSTROPHE") == Ok(("Na", "0x0025", "0x0027"))

parsed_lines : List (Result EawRange _)
parsed_lines = file |> Str.split_on("\n") |> List.map(parse_line)

original_ranges =
    parsed_lines
    |> List.keep_oks(|x| x)

# We can drop the Neutral ranges because those are the default
optimized_ranges =
    List.drop_if(original_ranges, |(eawp, _, _)| eawp == "N")

# The input file contains many consecutive ranges with the same property value.
# We will merge them into wider ranges to work with a smaller number of ranges.
merged_ranges =
    head_res = List.first(optimized_ranges)
    tail = List.drop_first(optimized_ranges, 1)
    res =
        when head_res is
            Err(_) -> crash("Something went wrong while parsing the input.")
            Ok(head) -> List.walk(tail, { merged: [], merging: head }, merge_op)

    List.append(res.merged, res.merging)

merge_op : { merged : List EawRange, merging : EawRange }, EawRange -> { merged : List EawRange, merging : EawRange }
merge_op = |{ merged, merging }, current_value|
    if merging.0 == current_value.0 and (Helpers.hex_str_to_u32(merging.2)) + 1 == (Helpers.hex_str_to_u32(current_value.1)) then
        {
            merged,
            merging: (merging.0, merging.1, current_value.2),
        }
    else
        {
            merged: List.append(merged, merging),
            merging: current_value,
        }

expect merge_op({ merged: [], merging: ("Na", "0x0020", "0x0020") }, ("Na", "0x0021", "0x0021")) == { merged: [], merging: ("Na", "0x0020", "0x0021") }
expect merge_op({ merged: [], merging: ("Na", "0x0020", "0x0020") }, ("Na", "0x0022", "0x0022")) == { merged: [("Na", "0x0020", "0x0020")], merging: ("Na", "0x0022", "0x0022") }

# Ranges grouped by the values of their property
grouped_ranges : Dict Str (List (Str, Str))
grouped_ranges =
    merged_ranges
    |> List.walk(
        Dict.empty({}),
        |s, range|
            Dict.update(
                s,
                range.0,
                |value|
                    when value is
                        Ok(lst) -> Ok(List.append(lst, (range.1, range.2)))
                        Err(Missing) -> Ok(List.single((range.1, range.2))),
            ),
    )

tests_str : Str
tests_str =
    range_to_test_str = |(start, end)|
        if start == end then
            "cp == ${start}"
        else
            "(${start} <= cp and cp <= ${end})"
    grouped_ranges
    |> Dict.map(
        |_, lst|
            (List.map(lst, range_to_test_str))
            |> Str.join_with(" or "),
    )
    |> Dict.map(
        |eawp, test|
            "if ${test} then (${eawp})",
    )
    |> Dict.values
    |> Str.join_with(" else ")
    |> Str.concat(" else N")

create_test : (U32, Str) -> Str
create_test = |(cp, eawp)|
    "expect east_asian_width_property(${Num.to_str(cp)}) == ${eawp}"

expect
    test = create_test(('Æ', "A"))
    expected = "expect east_asian_width_property(198) == A"
    test == expected

all_tests =
    tests = [
        # Ambiguous
        ('Æ', "A"),
        ('ⓩ', "A"),
        ('☎', "A"),
        # Halfwidth
        ('₩', "H"),
        ('｣', "H"),
        # Narrow
        ('¢', "Na"),
        ('¥', "Na"),
        ('¬', "Na"),
        # Wide
        ('〇', "W"),
        ('〡', "W"),
        ('〩', "W"),
        ('﹄', "W"),
        ('﹉', "W"),
        ('你', "W"),
        # Fullwidth
        ('Ａ', "F"),
        ('￦', "F"),
        # Neutral
        ('𑈸', "N"),
        ('𑌓', "N"),
        ('𑪊', "N"),
    ]
    List.map(tests, create_test) |> Str.join_with("\n\n")
