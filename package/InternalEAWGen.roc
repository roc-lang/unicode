## The purpose of this file is to generate the InternalEAW.roc file.
##
## This file will read the test data from `data/EastAsianWidth-15.1.0.txt`
## parse it and then generate function to test the East Asian Width property of a code point.
app [main!] {
    pf: platform "../../basic-cli/platform/main.roc",
}

import pf.File
import pf.Arg
import "data/EastAsianWidth-15.1.0.txt" as file : Str
import Helpers

EawRange : (Str, Str, Str)

main! = \raw_args ->
    args = List.map(raw_args, Arg.display)

    package_path =
        List.get(args, 1)
        |> Result.map_err?(\_ -> Exit(1, "Error: I got 0 arguments! Usage: roc InternalEAWGen.roc -- path/to/package/"))

    File.write_utf8!("${Helpers.remove_trailing_slash(package_path)}/InternalEAW.roc", template)

template =
    """
    ## WARNING This file is automatically generated. Do not edit it manually. ##
    module [eastAsianWidthProperty, eastAsianWidth]

    eastAsianWidth : U32 -> U32
    eastAsianWidth = \\codePoint ->
        when eastAsianWidthProperty codePoint is
            F | W | A -> 2
            H | N | Na -> 1

    eastAsianWidthProperty = \\cp -> ${tests_str}

    ${all_tests}
    """

# The ranges are specified as its starting point and an optional inclusive end point
# if it's length is greater than 1. The range is followed by the East_Asian_Width property
# separated by a semicolon.
# Examples:
# 0000..001F     ; N    # The property may be followed by comments
# 0020           ; Na
parse_line : Str -> Result EawRange _
parse_line = \line ->
    list_to_parsing_state = \rest -> { val: [], rest }

    start_hex_bytes =
        line
        |> Str.to_utf8
        |> list_to_parsing_state
        |> Helpers.take_hex_bytes

    end_hex_bytes =
        when start_hex_bytes.rest is
            ['.', '.', .. as rest] -> rest |> list_to_parsing_state |> Helpers.take_hex_bytes
            _ -> start_hex_bytes # This range has length 1. The start will be repeated as the end

    end_hex_bytes.rest
    |> List.split_first(';')
    |> Result.map(\{ after } -> after)
    |> Result.try(\commentd_eap -> List.split_first(commentd_eap, '#'))
    |> Result.map(\{ before } -> before)
    |> Result.try(Str.from_utf8)
    |> Result.map(Str.trim)
    |> Result.try(
        \eawp ->
            start_hex_bytes.val
            |> Str.from_utf8
            |> Result.map(\start -> (eawp, "0x${start}")),
    )
    |> Result.try(
        \(eawp, start) ->
            end_hex_bytes.val
            |> Str.from_utf8
            |> Result.map(\end -> (eawp, start, "0x${end}")),
    )

expect parse_line("0020           ; Na # Zs         SPACE") == Ok(("Na", "0x0020", "0x0020"))
expect parse_line("0025..0027     ; Na # Po     [3] PERCENT SIGN..APOSTROPHE") == Ok(("Na", "0x0025", "0x0027"))

parsed_lines : List (Result EawRange _)
parsed_lines = file |> Str.split_on("\n") |> List.map(parse_line)

original_ranges =
    parsed_lines
    |> List.keep_oks(\x -> x)

# We can drop the Neutral ranges because those are the default
optimized_ranges =
    List.drop_if(original_ranges, \(eawp, _, _) -> eawp == "N")

# The input file contains many consecutive ranges with the same property value.
# We will merge them into wider ranges to work with a smaller number of ranges.
merged_ranges =
    head_res = List.first(optimized_ranges)
    tail = List.drop_first(optimized_ranges, 1)
    res =
        when head_res is
            Err(_) -> crash("Something went wrong while parsing the input.")
            Ok(head) -> List.walk(tail, { merged: [], merging: head }, merge_op)

    List.append(res.merged, res.merging)

merge_op : { merged : List EawRange, merging : EawRange }, EawRange -> { merged : List EawRange, merging : EawRange }
merge_op = \{ merged, merging }, current_value ->
    if merging.0 == current_value.0 && (Helpers.hex_str_to_u32(merging.2)) + 1 == (Helpers.hex_str_to_u32(current_value.1)) then
        {
            merged,
            merging: (merging.0, merging.1, current_value.2),
        }
    else
        {
            merged: List.append(merged, merging),
            merging: current_value,
        }

expect merge_op({ merged: [], merging: ("Na", "0x0020", "0x0020") }, ("Na", "0x0021", "0x0021")) == { merged: [], merging: ("Na", "0x0020", "0x0021") }
expect merge_op({ merged: [], merging: ("Na", "0x0020", "0x0020") }, ("Na", "0x0022", "0x0022")) == { merged: [("Na", "0x0020", "0x0020")], merging: ("Na", "0x0022", "0x0022") }

# Ranges grouped by the values of their property
grouped_ranges : Dict Str (List (Str, Str))
grouped_ranges =
    merged_ranges
    |> List.walk(
        Dict.empty({}),
        \s, range ->
            Dict.update(
                s,
                range.0,
                \value ->
                    when value is
                        Ok(lst) -> Ok(List.append(lst, (range.1, range.2)))
                        Err(Missing) -> Ok(List.single((range.1, range.2))),
            ),
    )

tests_str : Str
tests_str =
    range_to_test_str = \(start, end) ->
        if start == end then
            "cp == ${start}"
        else
            "(${start} <= cp && cp <= ${end})"
    grouped_ranges
    |> Dict.map(
        \_, lst ->
            (List.map(lst, range_to_test_str))
            |> Str.join_with(" || "),
    )
    |> Dict.map(
        \eawp, test ->
            "if ${test} then (${eawp})",
    )
    |> Dict.values
    |> Str.join_with(" else ")
    |> Str.concat(" else N")

create_test : (U32, Str) -> Str
create_test = \(cp, eawp) ->
    "expect eastAsianWidthProperty ${Num.to_str(cp)} == ${eawp}"

expect
    test = create_test(('Ã†', "A"))
    expected = "expect eastAsianWidthProperty 198 == A"
    test == expected

all_tests =
    tests = [
        # Ambiguous
        ('Ã†', "A"),
        ('â“©', "A"),
        ('â˜', "A"),
        # Halfwidth
        ('â‚©', "H"),
        ('ï½£', "H"),
        # Narrow
        ('Â¢', "Na"),
        ('Â¥', "Na"),
        ('Â¬', "Na"),
        # Wide
        ('ã€‡', "W"),
        ('ã€¡', "W"),
        ('ã€©', "W"),
        ('ï¹„', "W"),
        ('ï¹‰', "W"),
        ('ğ¯ „', "W"),
        # Fullwidth
        ('ï¼¡', "F"),
        ('ï¿¦', "F"),
        # Neutral
        ('ğ‘ˆ¸', "N"),
        ('ğ‘Œ“', "N"),
        ('ğ‘ªŠ', "N"),
    ]
    List.map(tests, create_test) |> Str.join_with("\n\n")
