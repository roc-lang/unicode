## The purpose of this file is to generate the GraphemeTest.roc test suite.
##
## This file will read the test data from `data/GraphemeBreakTest-15.1.0.txt`
## parse it and then generate the individual tests.
app [main!] {
    pf: platform "../../basic-cli/platform/main.roc",
    parser: "../../roc-parser/package/main.roc",
}

import pf.Stdout
import parser.Parser exposing [Parser, const, keep, skip, one_of, one_or_more, many, chomp_while]
import parser.String exposing [parse_str, string, codeunit, codeunit_satisfies]
import "data/GraphemeBreakTest-15.1.0.txt" as input_file : Str
import Helpers exposing [hex_bytes_to_u32]
import CodePoint exposing [CodePoint]
import InternalCP exposing [from_u32_unchecked]

Rule : [GB1, GB2, GB3, GB4, GB5, GB6, GB7, GB8, GB9, GB9a, GB9b, GB9c, GB11, GB12, GB13, GB999]
TestTokens : List [BR Rule, NB Rule, CP CodePoint]

main! = |_args| Stdout.line!(template)

template : Str
template =

    tests =
        test_file
        |> List.keep_if(
            |test|
                # filter out any tests which aren't passing yet
                # progressively add these as support is added
                test.parsed
                |> List.keep_if(
                    |token|
                        when token is
                            BR(rule) if rule == GB9a or rule == GB9b or rule == GB9c -> Bool.true
                            NB(rule) if rule == GB9a or rule == GB9b or rule == GB9c -> Bool.true
                            _ -> Bool.false,
                )
                |> List.is_empty,
        )
        |> List.map(
            |test|
                # test : {lineNo : U16, lineStr : Str, parsed : List [BR Rule, NB Rule, CP CodePoint]}

                sanitised_line =
                    test.line_str
                    |> Str.replace_each("÷", "%") # replace %
                    |> Str.replace_each("×", "x") # replace X
                    |> Str.replace_each("	", " ") # replace tabs with a space

                code_points_list = test.parsed |> to_u32_list

                """

                # GraphemeBreakTest-15.1.0.txt:line ${Num.to_str(test.line_no)}
                # ${sanitised_line}
                expect
                    exp = Ok(${code_points_list |> Inspect.to_str})
                    got =
                        ${code_points_list |> List.join |> Inspect.to_str}
                        |> List.map(InternalCP.from_u32_unchecked)
                        |> CodePoint.to_str
                        |> Result.try(Grapheme.split)
                        |> Result.map_ok(to_code_point_list)

                    got == exp
                """,
        )
        |> Str.join_with("\n")

    """
    ## WARNING This file is automatically generated. Do not edit it manually. ##
    module []

    import CodePoint
    import Grapheme
    import InternalCP

    to_code_point_list : List Str -> List (List U32)
    to_code_point_list = |strings|
        strings
        |> List.map(|str|
            when str |> Str.to_utf8 |> CodePoint.parse_utf8 is
                Ok cps -> List.map(cps, CodePoint.to_u32)
                Err _ ->
                    crash \"expected valid utf8\"
        )

    ${tests}
    """

to_u32_list : TestTokens -> List (List U32)
to_u32_list = |tokens|
    to_u32s = |cps| cps |> List.map(CodePoint.to_u32)

    go : TestTokens, List CodePoint, List (List U32) -> List (List U32)
    go = |remaining, acc, strs|
        next = List.drop_first(remaining, 1)
        when remaining is
            [] -> if List.is_empty(acc) then strs else List.append(strs, to_u32s(acc))
            [BR(_), ..] -> go(next, [], (if List.is_empty(acc) then strs else List.append(strs, to_u32s(acc))))
            [NB(_), ..] -> go(next, acc, strs)
            [CP(cp), ..] -> go(next, List.append(acc, cp), strs)

    go(tokens, [], [])

test_file : List { line_no : U16, line_str : Str, parsed : TestTokens }
test_file =
    input_file
    |> Str.split_on("\n")
    |> List.map_with_index(|line_str, idx| { line_no: Num.to_u16((idx + 1)), line_str, parsed: [] })
    |> List.keep_if(|test| Str.starts_with(test.line_str, "÷ "))
    |> List.map(
        |test|
            when parse_str(test_parser, test.line_str) is
                Ok(Ok(parsed)) -> { test & parsed }
                Ok(Err(err)) -> crash("Unable to parse line ${Num.to_str(test.line_no)} completely, got err ${Inspect.to_str(err)}")
                Err(err) -> crash("Unable to parse line ${Num.to_str(test.line_no)} got err ${Inspect.to_str(err)}"),
    )

test_parser : Parser (List U8) (Result TestTokens _)
test_parser =
    const(|first| |second| zip(first, second) |> Result.map_ok(List.reverse))
    |> keep(first_half_parser)
    |> skip(string("	#  "))
    |> keep(second_half_parser)

expect
    parse_str(test_parser, "÷ 0020 ÷ 0020 ÷	#  ÷ [0.2] SPACE (Other) ÷ [999.0] SPACE (Other) ÷ [0.3]")
    == Ok(Ok([BR(GB1), CP(from_u32_unchecked(32)), BR(GB999), CP(from_u32_unchecked(32)), BR(GB2)]))

expect
    parse_str(test_parser, "÷ 0020 ÷ 000D ÷	#  ÷ [0.2] SPACE (Other) ÷ [5.0] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]")
    == Ok(Ok([BR(GB1), CP(from_u32_unchecked(32)), BR(GB5), CP(from_u32_unchecked(13)), BR(GB2)]))

code_point_parser : Parser (List U8) CodePoint
code_point_parser =
    is_hex = |b| (b >= '0' and b <= '9') or (b >= 'A' and b <= 'F')

    const(
        |bytes|
            bytes
            |> hex_bytes_to_u32
            |> from_u32_unchecked,
    )
    |> keep(one_or_more(codeunit_satisfies(is_hex)))

expect parse_str(code_point_parser, "094D") == Ok(from_u32_unchecked(2381))
expect parse_str(code_point_parser, "1F1E6") == Ok(from_u32_unchecked(127462))

break_rule_parser : Parser (List U8) Rule
break_rule_parser =
    one_of(
        [
            const(GB1) |> skip(string("[0.2]")),
            const(GB2) |> skip(string("[0.3]")),
            const(GB3) |> skip(string("[3.0] ")),
            const(GB4) |> skip(string("[4.0]")),
            const(GB5) |> skip(string("[5.0]")),
            const(GB6) |> skip(string("[6.0]")),
            const(GB7) |> skip(string("[7.0]")),
            const(GB8) |> skip(string("[8.0]")),
            const(GB9) |> skip(string("[9.0]")),
            const(GB9a) |> skip(string("[9.1]")),
            const(GB9b) |> skip(string("[9.2]")),
            const(GB9c) |> skip(string("[9.3]")),
            const(GB11) |> skip(string("[11.0]")),
            const(GB12) |> skip(string("[12.0]")),
            const(GB13) |> skip(string("[13.0]")),
            const(GB999) |> skip(string("[999.0]")),
        ],
    )

expect parse_str(break_rule_parser, "[999.0]") == Ok(GB999)
expect parse_str(break_rule_parser, "[0.2]") == Ok(GB1)

first_half_parser : Parser (List U8) (List [BR, NB, CP CodePoint])
first_half_parser =
    many(
        one_of(
            [
                const(BR) |> skip(string("÷")),
                const(NB) |> skip(string("×")),
                const(CP) |> skip(codeunit(' ')) |> keep(code_point_parser) |> skip(codeunit(' ')),
            ],
        ),
    )

expect parse_str(first_half_parser, "÷ 0020 ÷ 0020 ÷") == Ok([BR, CP(from_u32_unchecked(32)), BR, CP(from_u32_unchecked(32)), BR])

second_half_parser : Parser (List U8) (List [BR Rule, NB Rule])
second_half_parser =
    # NOTE Str.toUtf8 " ÷ " == [32, 195, 183, 32] : List U8
    # NOTE Str.toUtf8 " × " == [32, 195, 151, 32] : List U8
    many(
        one_of(
            [
                const(BR)
                |> skip(string("÷"))
                |> skip(codeunit(' '))
                |> keep(break_rule_parser)
                |> skip(chomp_while(|b| b != 195)),
                const(NB)
                |> skip(string("×"))
                |> skip(codeunit(' '))
                |> keep(break_rule_parser)
                |> skip(chomp_while(|b| b != 195)),
            ],
        ),
    )

expect parse_str(second_half_parser, "÷ [0.2] SPACE (Other) ÷ [999.0] SPACE (Other) ÷ [0.3]") == Ok([BR(GB1), BR(GB999), BR(GB2)])

# First half of the line with the test has the CodePoints we want, but the second half
# has the rules used which we also want, let's combine these to make life simpler and
# so we can test our implementation with more confidence by checking we apply the correct
# rule in the correct locations
zip : List [BR, NB, CP CodePoint], List [BR Rule, NB Rule] -> Result (List [BR Rule, NB Rule, CP CodePoint]) [Invalid Str]
zip = |first, second|
    when (List.first(first), List.first(second)) is
        (Ok(BR), Ok(BR(rule))) ->
            next = zip(List.drop_first(first, 1), List.drop_first(second, 1))?

            Ok(List.append(next, BR(rule)))

        (Ok(NB), Ok(NB(rule))) ->
            next = zip(List.drop_first(first, 1), List.drop_first(second, 1))?

            Ok(List.append(next, NB(rule)))

        (Ok(CP(cp)), _) ->
            next = zip(List.drop_first(first, 1), second)?

            Ok(List.append(next, CP(cp)))

        (Err(_), Err(_)) -> Ok([]) # base case
        _ -> Err(Invalid("expected first and second lists to match exactly got ${Inspect.to_str(T(first, second))}"))

expect
    answer =
        zip([BR, CP(from_u32_unchecked(35)), BR, CP(from_u32_unchecked(32)), BR], [BR(GB1), BR(GB999), BR(GB2)])
        |> Result.map_ok(List.reverse)
        |> Result.with_default([])

    answer == [BR(GB1), CP(from_u32_unchecked(35)), BR(GB999), CP(from_u32_unchecked(32)), BR(GB2)]
